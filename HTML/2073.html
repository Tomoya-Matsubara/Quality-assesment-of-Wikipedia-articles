<h2 id="muticommodity-flow-problem">Muticommodity Flow Problem</h2>
<p>A commodity is a pair of source and sink nodes in a network flow problem. For detailed definition of multicommodity flow problem, see <a href="Multi-commodity_flow_problem" title="wikilink">Multi-commodity flow problem</a>. In a multicommodity flow problem, there are <span class="math inline"><em>k</em></span>&lt;U+2265&gt;1 commodities, each with its own source <span class="math inline"><em>s</em><sub>i</sub></span>, sink <span class="math inline"><em>t</em><sub>i</sub></span>, and demand <span class="math inline"><em>D</em><sub>i</sub></span>. The objective is to simultaneously route <span class="math inline"><em>D</em><sub>i</sub></span> units of commodity <span class="math inline"><em>i</em></span> from <span class="math inline"><em>s</em><sub>i</sub></span> to <span class="math inline"><em>t</em><sub>i</sub></span> for each <span class="math inline"><em>i</em></span>, such that the total amount of all commodities passing through any edge is no greater than its capacity. (In the case of undirected edges, the sum of the flows in both directions can&lt;U+2019&gt;t exceed the capacity of the edge.).<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> Specially, a 1-commodity (or single commodity) flow problem is also known as a maximum flow problem (see <a href="Maximum_flow_problem" title="wikilink">Maximum flow problem</a>). According to the famous Ford-Fulkerson algorithm (see <a href="Ford-Fulkerson_algorithm" title="wikilink">Ford-Fulkerson algorithm</a>),the max-flow and min-cut are always equal in a 1-commodity flow problem.</p>
<h3 id="max-flow-and-min-cut">Max-flow and min-cut</h3>
<p>In a multicommodity flow problem, <em>max-flow</em> is the maximum value of <span class="math inline"><em>f</em></span>, where <span class="math inline"><em>f</em></span> is the common fraction of each commodity that is routed, such that <span class="math inline"><em>f</em><em>D</em><sub>i</sub></span> units of commodity <span class="math inline"><em>i</em></span> can be simultaneously routed for each <span class="math inline"><em>i</em></span> without violating any capacity constraints. <em>min-cut</em> is the minimum of all cuts of the ratio <span class="math inline"><em>φ</em></span> of the capacity of the cut to the demand of the cut. Max-flow is always upper bounded by the min-cut for a multicommodify flow problem.</p>
<h3 id="uniform-multicommodity-flow-problem">Uniform multicommodity flow problem</h3>
<p>In a uniform multicommodity flow problem, there is a commodity for every pair of nodes and the demand for every commodity is the same. (Without loss of generality, the demand for every commodity is set to one.) The underlying network and capacities are arbitrary.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<h3 id="product-multicommodity-flow-problem">Product multicommodity flow problem</h3>
<p>In a product multicommodity flow problem, there is a nonnegative weight for each node <span class="math inline"><em>v</em> ∈ <em>V</em></span> in graph <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>. The demand for the commodity between nodes <span class="math inline"><em>u</em></span> and <span class="math inline"><em>v</em></span> is the product of the weights of node <span class="math inline"><em>u</em></span> and node <span class="math inline"><em>v</em></span>. The uniform multicommodity flow problem is a special case of the product multicommodity flow problem for which the weight is set to 1 for all nodes <span class="math inline"><em>u</em> ∈ <em>V</em></span>. <a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<h3 id="duality-of-linear-programming">Duality of Linear Programming</h3>
<p>In general, the dual of a multicommodity flow problem for a graph <span class="math inline"><em>G</em></span> is the problem of apportioning a fixed amount of weight (where weights can be considered as distances) to the edges of <span class="math inline"><em>G</em></span> such that to maximize the cumulative distance between the source and sink pairs <a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>. (See <a href="Linear_programming" title="wikilink">Linear programming</a> for detailed introduction of the duality of linear programming.)</p>
<h3 id="history">History</h3>
<p>The research on the relationship between the max-flow and min-cut of multicommodity flow problem has obtained great interest since Ford and Fulkterson's result for 1-commodity flow problems. Hu <a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> showed that the max-flow and min-cut are always equal for two commodities. Okamura and Seymour <a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> illustrated a 4-commodity flow problem with max-flow equals to 3/4 and min-cut equals 1. Shahrokhi and Matula <a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> also proved that the max-flow and min-cut are equal provided the dual of the flow problem satisfies a certain cut condition in a uniform multicommodity flow problem. Many other researchers also showed concrete research results in similar problems <a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> <a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a> <a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a> </br> For a general network flow problem, the max-flow is within a factor of <span class="math inline"><em>k</em></span> of the min-cut since each commodity can be optimized separately using <span class="math inline">1/<em>k</em></span> of the capacity of each edge. This is not a good result especially in case of large numbers of commodities. <a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a></p>
<h2 id="approximate-max-flow-min-cut-theorems">Approximate Max-Flow Min-Cut Theorems</h2>
<h3 id="theorems-of-uniform-multicommodity-flow-problems">Theorems of uniform multicommodity flow problems</h3>
<p>There are two theorems first introduced by Tom Leighton and Satish Rao in 1988 <a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a> and then extended in 1999 <a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a>. Theorem 2 gives a tighter bound compared to Theorem 1.</p>
<p><strong>Theorem 1.</strong> <em>For any <span class="math inline"><em>n</em></span>, there is an <span class="math inline"><em>n</em></span>-node uniform multicommodity flow problem with max-flow <span class="math inline"><em>f</em></span> and min-cut <span class="math inline"><em>φ</em></span> for which <span class="math inline"><em>f</em></span>&lt;U+2264&gt;<span class="math inline">$O(\frac{\varphi}{\log n})$</span>.</em><a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a></p>
<p><strong>Theorem 2.</strong> <em>For any uniform multicommodity flow problem, <span class="math inline">$\Omega(\frac{\varphi}{\log n})$</span>&lt;U+2264&gt;<span class="math inline"><em>f</em></span>&lt;U+2264&gt;<span class="math inline"><em>φ</em></span>, where <span class="math inline"><em>f</em></span> is the max-flow and <span class="math inline"><em>φ</em></span> is the min-cut of the uniform multicommodity flow problem.</em><a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a></p>
<p>To prove Theorem 2, both the max-flow and the min-cut should be discussed. For the max-flow, the techniques from duality theory of linear programming have to be employed. According to the duality theory of linear programming, an optimal distance function results in a total weight that is equal to the max-flow of the uniform multicommodity flow problem. For the min-cut, a 3-stage process has to be followed:<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a> <a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a> </br>Stage 1: Consider the dual of uniform commodity flow problem and use the optimal solution to define a graph with distance labels on the edges. </br>Stage 2: Starting from a source or a sink, grow a region in the graph until find a cut of small enough capacity separating the root from its mate. </br>Stage 3: Remove the region and repeat the process of stage 2 until all nodes get processed.</p>
<h3 id="generalized-to-product-multicommodity-flow-problem">Generalized to product multicommodity flow problem</h3>
<p><strong>Theorem 3.</strong> <em>For any product multicommodity flow problem with <span class="math inline"><em>k</em></span> commodities, <span class="math inline">$\Omega(\frac{\varphi}{\log k})$</span>&lt;U+2264&gt;<span class="math inline"><em>f</em></span>&lt;U+2264&gt;<span class="math inline"><em>φ</em></span>, where <span class="math inline"><em>f</em></span> is the max-flow and <span class="math inline"><em>φ</em></span> is the min-cut of the product multicommodity flow problem.</em> <a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a> </br>The proof methodology is similar as it is for Theorem 2, the major difference is to take node weights into consideration.</p>
<h3 id="extended-to-directed-multicommodity-flow-problem">Extended to directed multicommodity flow problem</h3>
<p>In a directed multicommodity flow problem, each edge has a direction, and the flow is restricted to move in the specified direction. In a directed uniform multicommodity flow problem, the demand is set to 1 for every directed edge. </br><strong>Theorem 4.</strong> <em>For any directed uniform multicommodity flow problem with <span class="math inline"><em>n</em></span> nodes, <span class="math inline">$\Omega(\frac{\varphi}{\log n})$</span>&lt;U+2264&gt;<span class="math inline"><em>f</em></span>&lt;U+2264&gt;<span class="math inline"><em>φ</em></span>, where <span class="math inline"><em>f</em></span> is the max-flow and <span class="math inline"><em>φ</em></span> is the min-cut of the uniform multicommodity flow problem.</em> <a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a> </br>The major difference in the proof methodology compared to Theorem 2 is that, now the edge directions need to be considered when defining distance labels in stage 1 and for growing the regions in stage 2, more details can be found in.<a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a></p>
<p>Similarly, for product multicommodity flow problem, we have the following extended theorem: </br> <strong>Theorem 5.</strong> <em>For any directed product multicommodity flow problem with <span class="math inline"><em>k</em></span> commodities, <span class="math inline">$\Omega(\frac{\varphi}{\log k})$</span>&lt;U+2264&gt;<span class="math inline"><em>f</em></span>&lt;U+2264&gt;<span class="math inline"><em>φ</em></span>, where <span class="math inline"><em>f</em></span> is the max-flow and <span class="math inline"><em>φ</em></span> is the directed min-cut of the product multicommodity flow problem.</em> <a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a></p>
<h2 id="applications-to-approximation-algorithms">Applications to Approximation Algorithms</h2>
<p>The above theorems are very useful to design approximation algorithms (see <a href="Approximation_algorithm" title="wikilink">Approximation algorithm</a>) for NP-hard problems (see <a href="NP-hard" class="uri" title="wikilink">NP-hard</a>), such as the graph partition problem and its variations (see <a href="Graph_partition" title="wikilink">Graph partition</a>). Here below we briefly introduce a few examples, and the in-depth elaborations can be found in:<a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a></p>
<h3 id="sparsest-cuts">Sparsest cuts</h3>
<p>A sparsest cut of a graph <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span> is a partition for which the ratio of the number of edges connecting the two partitioned components over the product of the numbers of nodes of both components. This is a NP-hard problem, and it can be approximated to within <span class="math inline"><em>O</em>(log <em>n</em>)</span> factor using Theorem 2. Also, a sparsest cut problem with weighted edges, weighted nodes or directed edges can be approximated within an <span class="math inline"><em>O</em>(log <em>p</em>)</span> factor where <span class="math inline"><em>p</em></span> is the number of nodes with nonzero weight according to Theorem 3, 4 and 5.</p>
<h3 id="balanced-cuts-and-separators">Balanced cuts and separators</h3>
<p>In some applications, we want to find a small cut in a graph <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span> that partitions the graph into nearly equal-size pieces. We usually call a cut <em>b-balanced</em> or a <em>(b,1-b)-separator</em> (for b&lt;U+2264&gt;1/2) if <span class="math inline"><em>b</em><em>π</em>(<em>V</em>)</span>&lt;U+2264&gt;<span class="math inline"><em>π</em>(<em>U</em>)</span>&lt;U+2264&gt;<span class="math inline">(1 − <em>b</em>)<em>π</em>(<em>V</em>)</span> where <span class="math inline"><em>π</em>(<em>U</em>)</span> is the sum of the node weights in <span class="math inline"><em>U</em></span>. This is also a NP-hard problem. In <a href="#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a> , there is a approximation algorithm designed for this problem, and the core idea is that <span class="math inline"><em>G</em></span> has a b-balanced cut of size <span class="math inline"><em>S</em></span>, then we find a b'-balanced cut of size <span class="math inline"><em>O</em>(<em>S</em>log (<em>n</em>/<em>b</em>) − <em>b</em>′)</span> for any b' where b'&lt;b and b'&lt;U+2264&gt;1/3. Then repeat the process then finally obtain the total weight of the edges in the cut is at most <span class="math inline">$O(\frac{S\log n}{b-b'})$</span>.</p>
<h3 id="vlsi-layout-problems">VLSI layout problems</h3>
<p>It's helpful to find a layout of minimum size when designing a VLSI circuit, such problem can often be modeled as a graph embedding problem. The objective is to find an embedding for which the layout area is minimized. Finding the minimum layout area is also NP-hard. An approximation algorithm is introduced in <a href="#fn24" class="footnote-ref" id="fnref24"><sup>24</sup></a> and the result is <span class="math inline"><em>O</em>(log<sup>6</sup><em>n</em>)</span> times optimal.</p>
<h3 id="forwarding-index-problem">Forwarding index problem</h3>
<p>Given an <span class="math inline"><em>n</em></span>-node graph <span class="math inline"><em>G</em></span> and an embedding of <span class="math inline"><em>K</em><sub><em>n</em></sub></span> in <span class="math inline"><em>G</em></span>, Chung et al. <a href="#fn25" class="footnote-ref" id="fnref25"><sup>25</sup></a> defined the <em>forwarding index</em> of the embedding to be the maximum number of paths (each corresponding to an edge of <span class="math inline"><em>K</em><sub><em>n</em></sub></span>) that pass through any node of <span class="math inline"><em>G</em></span>. The objective is to find an embedding that minimizes the forwarding index. According to the embedding approaches introduced in <a href="#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a>, it is possible to bound the node and edge-forwarding indices to within an <span class="math inline"><em>O</em>(log <em>n</em>)</span>-factor for every graph <span class="math inline"><em>G</em></span>.</p>
<h3 id="planar-edge-deletion">Planar edge deletion</h3>
<p>Tragoudas<a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a> uses the approximation algorithm for balanced separators to find a set of <span class="math inline">$O((R\log n + \sqrt{nR})\log\frac{n}{R})$</span> edges whose removal from a bounded-degree graph <span class="math inline"><em>G</em></span> results in a planar graph, where <span class="math inline"><em>R</em></span> is the minimum number of edges that need to be removed from <span class="math inline"><em>G</em></span> before it becomes planar. It remains an open question if there is a polylog <span class="math inline"><em>n</em></span> times optimal approximation algorithm for <span class="math inline"><em>R</em></span>.<a href="#fn28" class="footnote-ref" id="fnref28"><sup>28</sup></a></p>
<h2 id="see-also">See Also</h2>
<p><a href="Multi-commodity_flow_problem" title="wikilink">Multi-commodity flow problem</a><br />
<a href="Linear_programming" title="wikilink">Linear programming</a><br />
<a href="Ford-Fulkerson_algorithm" title="wikilink">Ford-Fulkerson algorithm</a><br />
<a href="Max-flow_min-cut_theorem" title="wikilink">Max-flow min-cut theorem</a><br />
<a href="Maximum_flow_problem" title="wikilink">Maximum flow problem</a><br />
<a href="Minimum_cut" title="wikilink">Minimum cut</a><br />
<a href="Flow_network" title="wikilink">Flow network</a><br />
<a href="Approximation_algorithm" title="wikilink">Approximation algorithm</a><br />
<a href="NP-hard" class="uri" title="wikilink">NP-hard</a><br />
<a href="Graph_partition" title="wikilink">Graph partition</a></p>
<h2 id="references">References</h2>

<section class="footnotes">
<hr />
<ol>
<li id="fn1"><a href="#fnref1" class="footnote-back">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5" class="footnote-back">↩</a></li>
<li id="fn6"><a href="#fnref6" class="footnote-back">↩</a></li>
<li id="fn7"><a href="#fnref7" class="footnote-back">↩</a></li>
<li id="fn8"><a href="#fnref8" class="footnote-back">↩</a></li>
<li id="fn9"><a href="#fnref9" class="footnote-back">↩</a></li>
<li id="fn10"><a href="#fnref10" class="footnote-back">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12" class="footnote-back">↩</a></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"><a href="#fnref25" class="footnote-back">↩</a></li>
<li id="fn26"></li>
<li id="fn27"><a href="#fnref27" class="footnote-back">↩</a></li>
<li id="fn28"></li>
</ol>
</section>
